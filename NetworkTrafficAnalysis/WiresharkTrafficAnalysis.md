## Wireshark Traffic Analysis

### Nmap Scans

Nmap is a widely used network scanning tool for host discovery and service enumeration. SOC analysts must recognize traffic patterns generated by common Nmap scan types to identify reconnaissance activity.

Common scan types:
- TCP Connect Scan (`-sT`)
- TCP SYN Scan (`-sS`)
- UDP Scan (`-sU`)

Useful Wireshark filters for scan identification:
- `tcp`, `udp`
- SYN only: `tcp.flags.syn == 1`
- ACK only: `tcp.flags.ack == 1`
- SYN+ACK: `tcp.flags == 18`
- RST: `tcp.flags.reset == 1`
- FIN: `tcp.flags.fin == 1`

TCP Connect Scan characteristics:
- Completes the TCP three-way handshake
- Used by non-privileged users
- Window size typically greater than 1024
- Open port: SYN → SYN/ACK → ACK
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

TCP SYN Scan characteristics:
- Half-open scan (handshake not completed)
- Used by privileged users
- Smaller window size (≤ 1024)
- Open port: SYN → SYN/ACK → RST
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size <= 1024`

UDP Scan characteristics:
- No handshake mechanism
- Open ports usually do not respond
- Closed ports return ICMP Destination Unreachable (Type 3, Code 3)
- ICMP packets encapsulate the original UDP request
- Detection filter:
  `icmp.type == 3 and icmp.code == 3`

Exercise findings (Exercise.pcapng):

Q. How many TCP Connect scans are present in the capture?

To identify TCP Connect scans, the following filter was used:
`tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

- `tcp.flags.syn == 1` indicates a new connection attempt
- `tcp.flags.ack == 0` confirms this is the first packet of the handshake (not a response)
- `tcp.window_size > 1024` suggests a full TCP connection expecting data, typical of TCP Connect scans

This filter isolates outbound scan attempts from the scanner.  
The result showed **1000 TCP Connect scans**.

Q. Which scan type was used to scan TCP port 80?

TCP port 80 traffic was reviewed within the TCP Connect scan results identified above.  
All scan attempts on port 80 followed a full TCP handshake pattern, confirming a **TCP Connect scan**.

Q. How many UDP closed-port messages are present?

UDP closed ports were identified using ICMP error responses:
`icmp.type == 3 and icmp.code == 3`

- ICMP Type 3 indicates Destination Unreachable
- ICMP Code 3 specifies Port Unreachable

This filter revealed **1083 ICMP responses**, indicating UDP closed-port scan results.

Q. Which UDP port is open in the 55–70 port range?

UDP traffic in the 55–70 port range was correlated with ICMP error responses.  
Port **68** generated UDP traffic **without corresponding ICMP Type 3 Code 3 responses**, indicating an open UDP service.


---

### ARP Poisoning / Spoofing (Man-In-The-Middle)

ARP (Address Resolution Protocol) maps IP addresses to MAC addresses on a local network. ARP poisoning (also known as ARP spoofing or MITM attack) exploits the lack of authentication in ARP by sending malicious ARP packets to manipulate IP-to-MAC mappings. The attacker positions themselves between the victim and the gateway to intercept traffic.

Key ARP characteristics:
- Works only on the local network
- Used for MAC-to-IP resolution
- Not secure and not routable
- No authentication mechanism
- Common packet types: request, response, gratuitous ARP

Basic ARP investigation filter:
`arp`

Useful ARP filters for detection:
- ARP requests: `arp.opcode == 1`
- ARP replies: `arp.opcode == 2`
- ARP scanning activity:
  `((arp) && (arp.opcode == 1)) && (arp.src.hw_mac == <target-mac>)`
- Possible ARP poisoning indicators:
  `arp.duplicate-address-detected`
  `arp.duplicate-address-frame`
- Suspicious destination MAC:
  `arp.dst.hw_mac == 00:00:00:00:00:00`

A suspicious ARP condition occurs when multiple MAC addresses claim ownership of the same IP address. Wireshark flags this as a duplicate address, but analysts must determine which packet is malicious by correlating timing, frequency, and network roles (gateway vs host).

Traffic analysis revealed a MAC address ending in **b4** repeatedly crafting ARP requests and responses:
- Legitimate ownership: MAC **b4** → IP **192.168.1.25**
- Spoofed claim: MAC **b4** also claimed **192.168.1.1** (likely gateway)
- Multiple ARP requests targeting a range of IPs indicated ARP flooding

This behavior confirms both **ARP spoofing** and **ARP flooding** attempts originating from the same host.

Further inspection of HTTP traffic initially appeared normal at the IP layer. After adding MAC address columns, all HTTP packets destined for the victim were observed flowing through the MAC ending in **b4**, confirming a successful MITM attack.

Final role identification:
- Attacker: MAC **00:0c:29:e2:18:b4** → IP **192.168.1.25**
- Gateway: MAC **50:78:b3:f3:cd:f4** → IP **192.168.1.1**
- Victim: MAC **00:0c:29:98:c7:a8** → IP **192.168.1.12**

This demonstrates how ARP poisoning enables traffic interception without altering IP-level communication, highlighting the importance of MAC-level inspection during investigations.


Exercise findings (ARP Exercise pcap):

Q. What is the number of ARP requests crafted by the attacker?

The following filter was used to isolate ARP requests sent by the attacker:
`arp.opcode == 1 && eth.src == 00:0c:29:e2:18:b4`

- `arp.opcode == 1` filters ARP request packets
- `eth.src == 00:0c:29:e2:18:b4` limits results to the attacker’s MAC address

This query revealed **284 ARP requests** crafted by the attacker.

Q. What is the number of HTTP packets received by the attacker?

HTTP traffic destined for the attacker was identified using:
`http && eth.dst == 00:0c:29:e2:18:b4`

- `http` filters cleartext HTTP traffic
- `eth.dst` confirms packets forwarded to the attacker’s MAC during MITM

This query returned **90 HTTP packets** received by the attacker.

Q. What is the number of sniffed username and password entries?

Credential-related HTTP payloads were filtered using:
`http contains uname`

- `contains` performs a case-sensitive string search
- `uname` matches username fields observed in HTTP form submissions

This revealed **6 username and password entries**.

Q. What is the password of "Client986"?

Client-specific HTTP traffic was identified using:
`http matches client986`

- `matches` performs a case-insensitive regex match
- Useful when exact casing is unknown

Inspection of the matching HTTP request revealed the password:
**clientnothere!**

Q. What is the comment provided by "Client354"?

Traffic related to the client was filtered using:
`http matches client354`

The HTTP payload inspection showed the following comment:
**Nice work!**

---

### Identifying Hosts: DHCP, NetBIOS and Kerberos

When investigating compromises or malware activity, identifying hosts and users is critical for defining the investigation scope and correlating malicious traffic. Beyond IP–MAC mappings, protocols such as DHCP, NetBIOS, and Kerberos provide valuable host and user attribution data.

Enterprise environments often use predictable naming conventions for hosts and users. While this simplifies asset management, it can also be abused by attackers, making protocol-level verification essential for analysts.

Protocols commonly used for host and user identification:
- DHCP (Dynamic Host Configuration Protocol)
- NetBIOS Name Service (NBNS)
- Kerberos

DHCP analysis focuses on extracting hostname, requested IP, and lease information from DHCP option fields. NetBIOS analysis helps identify workstation names through registration and query traffic. Kerberos analysis enables user and host identification in Windows domain environments by inspecting authentication metadata.

Exercise findings (dhcp-netbios.pcap & kerberos.pcap):

Q. What is the MAC address of the host "Galaxy A30"?

The following display filter was used:
`frame matches Galaxy`

This filter performs a case-insensitive search across packet frames, allowing quick identification of DHCP packets containing the hostname. Inspection of the matching DHCP Request revealed the MAC address:

**9a:81:41:cb:96:6c**

Q. How many NetBIOS registration requests does the "LIVALJM" workstation have?

The following filter was applied:
`(nbns.name matches LIVALJM) && (nbns.flags.opcode == 5)`

- `nbns.name matches LIVALJM` identifies NBNS packets related to the workstation
- `nbns.flags.opcode == 5` filters NetBIOS name registration requests

This resulted in **16 NetBIOS registration requests**.

Q. Which host requested the IP address "172.16.13.85"?

The DHCP request was identified using:
`dhcp && dhcp.option.requested_ip_address == 172.16.13.85`

After selecting a DHCP Request packet and inspecting the hostname option, the requesting host was identified as:

**Galaxy-A12**

Q. What is the IP address of the user "u5"? (defanged format)

Kerberos user activity was identified using:
`kerberos.CNameString contains "u5"`

- `CNameString` represents the client principal name (user or host)
- Values without `$` indicate user accounts

Packet inspection revealed the user "u5" associated with the following IP address:

**10[.]1[.]12[.]2**

Q. What is the hostname of the available host in the Kerberos packets?

Kerberos packets were filtered using:
`kerberos.CNameString`

Packets containing values ending with `$` were inspected, as these represent hostnames rather than user accounts. The available hostname identified was:

**xp1$**

---

### Tunnelling Traffic: ICMP and DNS

Traffic tunnelling hides data inside legitimate protocols to move information across network boundaries. While commonly used by enterprises for secure communication, attackers abuse trusted protocols like ICMP and DNS for data exfiltration and command-and-control (C2) communication to bypass security controls.

Because these protocols are routinely allowed through network perimeters, detecting tunnelling requires identifying anomalies rather than relying on simple allow/deny logic.

ICMP tunnelling abuses the ICMP payload field to encapsulate other protocols such as SSH, TCP, or HTTP. DNS tunnelling abuses long or abnormal DNS queries, often encoding data inside subdomain labels.

ICMP tunnelling indicators include:
- High volume of ICMP traffic
- Abnormal or consistent packet sizes
- Encapsulated protocol data inside ICMP payloads

DNS tunnelling indicators include:
- Excessively long DNS query names
- Encoded or random-looking subdomains
- Repeated queries to a single domain
- Known tunnelling tools (e.g., dnscat, dns2tcp)

Exercise findings (icmp-tunnel.pcap & dns.pcap):

Q. Which protocol is used in the ICMP tunnelling activity?

ICMP packets with unusually large payloads were isolated using:
`data.len > 64 and icmp`

- Normal ICMP echo requests are typically 64 bytes
- Larger payloads indicate possible data encapsulation

Inspection of the ICMP payload revealed encapsulated **SSH** traffic, confirming ICMP-based tunnelling.

Q. What is the suspicious main domain receiving anomalous DNS queries? (defanged format)

DNS tunnelling activity was isolated using:
`dns.qry.name.len > 15 and !mdns`

- Long query names indicate encoded subdomain data
- `!mdns` removes local multicast DNS noise

Analysis showed repeated anomalous DNS queries targeting the following domain:

**dataexfil[.]com**

---

### Cleartext Protocol Analysis: FTP

Cleartext protocol analysis becomes challenging at scale. While credentials and commands are readable, a SOC analyst must extract statistics, identify abuse patterns, and summarize attacker behavior rather than simply following streams.

FTP prioritizes simplicity over security and transmits credentials and commands in cleartext, making it highly vulnerable to interception and abuse. Common risks include credential theft, brute-force attacks, malware uploads, and data exfiltration.

FTP investigation relies on correlating response codes, commands, and file-transfer activity to identify attacker intent.

Key FTP indicators:
- Authentication attempts (success and failure)
- File access and transfer activity
- Permission modification commands
- Repeated failed logins indicating brute-force behavior

Exercise findings (ftp.pcap):

Q. How many incorrect login attempts are there?

Incorrect login attempts were identified using:
`ftp && ftp.response.arg == "Login incorrect."`

- `ftp` limits traffic to FTP protocol
- `ftp.response.arg == "Login incorrect."` directly matches failed authentication responses returned by the server

This filter revealed **737 incorrect login attempts**, indicating brute-force activity.

Q. What is the size of the file accessed by the "ftp" account?

FTP activity related to the "ftp" account was identified using:
`ftp contains "ftp"`

After locating the first `USER ftp` command, the packet was right-clicked and filtered using:
**Conversation Filter → TCP**

This isolated the full FTP session for that user. Scrolling through the conversation revealed a file transfer where the server response contained:

`Response arg: 39424`

This indicates the accessed file size was **39424 bytes**.

Q. What is the filename uploaded by the adversary?

The uploaded filename was identified during the same TCP conversation filtered in the previous step.

Inspection of the FTP commands within the session revealed the uploaded file:

**resume.doc**

Q. What command was used to change the execution permissions of the uploaded file?

Post-upload FTP commands were reviewed by continuing to scroll through the same TCP conversation.

The adversary attempted to modify file permissions using the following command:

**CHMOD 777 resume.doc**

---

### Cleartext Protocol Analysis: HTTP

HTTP is a cleartext, request–response, client–server protocol and forms the backbone of web traffic. Because it is unencrypted and commonly allowed through network perimeters, HTTP traffic is frequently abused by adversaries. HTTP analysis is critical for detecting phishing pages, web attacks, data exfiltration, and command-and-control (C2) activity.

HTTP traffic can be filtered using:
http  
http2  

Common request methods observed during analysis:
GET  
POST  

Useful request filters:
http.request  
http.request.method == "GET"  
http.request.method == "POST"  

HTTP response status codes help identify success, errors, and access issues:
200 (OK) – request successful  
301 / 302 – redirection  
400 – bad request  
401 – unauthorised  
403 – forbidden  
404 – not found  
405 – method not allowed  
408 – request timeout  
500 – internal server error  
503 – service unavailable  

Response-based filters used:
http.response.code == 200  
http.response.code == 401  
http.response.code == 403  
http.response.code == 404  
http.response.code == 405  
http.response.code == 503  

HTTP parameters are valuable for identifying targets and anomalies:
User-Agent – client browser / tool identification  
Request URI – requested resource  
Full URI – complete resource path  
Server / Host – backend service and hostname  

Parameter-based filters:
http.user_agent  
http.user_agent contains "nmap"  
http.request.uri contains "admin"  
http.request.full_uri contains "admin"  
http.server contains "apache"  
http.host contains "keyword"  
http.connection == "Keep-Alive"  
data-text-lines contains "keyword"  

User-Agent analysis is especially important, as attackers often attempt to mimic legitimate traffic. Indicators of anomalous or malicious user agents include:
Different user agents from the same host in a short time
Non-standard or custom user-agent strings
Subtle spelling errors (typosquatting)
Known audit or attack tools (Nmap, Nikto, sqlmap, Wfuzz)
Encoded or payload-like data inside the user-agent field

Useful hunting filters:
(http.user_agent contains "sqlmap")  
(http.user_agent contains "Nmap")  
(http.user_agent contains "Wfuzz")  
(http.user_agent contains "Nikto")  

For Log4j exploitation analysis, known attack characteristics include:
POST-based delivery
Cleartext indicators such as "jndi" and "Exploit.class"
Encoded payloads in headers like User-Agent

Filters used for Log4j detection:
http.request.method == "POST"  
(frame contains "jndi")  
(frame contains "Exploit")  
(http.user_agent contains "$")  
(http.user_agent contains "==")  

Exercise findings (HTTP):

Q. Investigate the user agents. What is the number of anomalous "user-agent" types?

User-Agent was added as a column and manually reviewed across packets.
Anomalies were identified based on non-standard values, inconsistent OS versions, and modified strings.
A key validation question used during analysis was whether "Windows NT 6.4" legitimately exists.

Total anomalous user-agent types identified:
6

Q. What is the packet number with a subtle spelling difference in the user agent field?

Manual inspection revealed a typosquatted user-agent value:
"Mozlila" instead of "Mozilla"

Packet number:
52

Q. Locate the "Log4j" attack starting phase. What is the packet number?

The filter `frame contains "jndi"` was used to identify the first malicious payload.

Attack starting packet number:
444

Q. Locate the "Log4j" attack starting phase and decode the base64 command. What is the IP address contacted by the adversary?

From packet 444, the encoded payload in the User-Agent field was extracted.
The value was decoded using CyberChef (Base64 decoding).
The decoded command revealed the destination IP address, which was then defanged.

Adversary-controlled IP address:
62[.]210[.]130[.]250

---

### Encrypted Protocol Analysis: Decrypting HTTPS

HTTPS uses TLS to encrypt HTTP traffic, protecting data against sniffing and interception. While this improves security, it also means packet contents (URLs, headers, payloads) are unreadable without the correct decryption keys. Since attackers also rely on HTTPS to hide malicious activity, a SOC analyst must know how to decrypt TLS traffic using key log files and investigate the decrypted sessions.

TLS traffic initially appears encrypted, and only handshake metadata (Client Hello / Server Hello) is visible. By supplying a valid SSL/TLS key log file generated during the capture, Wireshark can decrypt the traffic and expose HTTP/2 requests, headers, and objects for analysis.

Key points for HTTPS/TLS analysis:
- TLS handshake identifies communicating endpoints
- Client Hello (`tls.handshake.type == 1`) and Server Hello (`tls.handshake.type == 2`) mark session initiation
- Decryption requires a matching SSL key log file generated during capture
- Once decrypted, HTTP/2 traffic becomes fully visible, including headers and exported objects

Exercise findings (Exercise.pcap):

Q. What is the frame number of the "Client Hello" message sent to "accounts.google.com"?

The following filter was used to locate TLS packets containing the target hostname:
`frame contains "accounts.google.com"`

This revealed the Client Hello message sent to the domain at **frame 16**.

Q. After decrypting the traffic using the provided key log file, how many HTTP/2 packets are present?

Traffic was initially encrypted as TLS 1.3. Decryption was enabled by navigating to:
Edit → Preferences → Protocols → TLS → (Pre)-Master-Secret Log Filename  
and selecting `KeysLogFile.txt`.

Once applied, previously encrypted packets were decrypted and reclassified as HTTP/2.  
Filtering with:
`http2`

showed **115 HTTP/2 packets**, confirming successful decryption.

Q. What is the authority header value in Frame 322?

With the `http2` filter applied, the packet list was navigated to frame 322.  
The HTTP/2 headers were inspected, and the `:authority` field was identified.

After defanging, the authority value is:
**safebrowsing[.]googleapis[.]com**

Q. What is the hidden flag found in the decrypted traffic?

After decryption, HTTP objects were reviewed via:
File → Export Objects → HTTP

The first exported object was saved and opened in a text editor.  
The flag was found embedded in the object content:

**FLAG{THM-PACKETMASTER}**

---



