## Wireshark Traffic Analysis

### Nmap Scans

Nmap is a widely used network scanning tool for host discovery and service enumeration. SOC analysts must recognize traffic patterns generated by common Nmap scan types to identify reconnaissance activity.

Common scan types:
- TCP Connect Scan (`-sT`)
- TCP SYN Scan (`-sS`)
- UDP Scan (`-sU`)

Useful Wireshark filters for scan identification:
- `tcp`, `udp`
- SYN only: `tcp.flags.syn == 1`
- ACK only: `tcp.flags.ack == 1`
- SYN+ACK: `tcp.flags == 18`
- RST: `tcp.flags.reset == 1`
- FIN: `tcp.flags.fin == 1`

TCP Connect Scan characteristics:
- Completes the TCP three-way handshake
- Used by non-privileged users
- Window size typically greater than 1024
- Open port: SYN → SYN/ACK → ACK
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

TCP SYN Scan characteristics:
- Half-open scan (handshake not completed)
- Used by privileged users
- Smaller window size (≤ 1024)
- Open port: SYN → SYN/ACK → RST
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size <= 1024`

UDP Scan characteristics:
- No handshake mechanism
- Open ports usually do not respond
- Closed ports return ICMP Destination Unreachable (Type 3, Code 3)
- ICMP packets encapsulate the original UDP request
- Detection filter:
  `icmp.type == 3 and icmp.code == 3`

Exercise findings (Exercise.pcapng):

Q. How many TCP Connect scans are present in the capture?

To identify TCP Connect scans, the following filter was used:
`tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

- `tcp.flags.syn == 1` indicates a new connection attempt
- `tcp.flags.ack == 0` confirms this is the first packet of the handshake (not a response)
- `tcp.window_size > 1024` suggests a full TCP connection expecting data, typical of TCP Connect scans

This filter isolates outbound scan attempts from the scanner.  
The result showed **1000 TCP Connect scans**.

Q. Which scan type was used to scan TCP port 80?

TCP port 80 traffic was reviewed within the TCP Connect scan results identified above.  
All scan attempts on port 80 followed a full TCP handshake pattern, confirming a **TCP Connect scan**.

Q. How many UDP closed-port messages are present?

UDP closed ports were identified using ICMP error responses:
`icmp.type == 3 and icmp.code == 3`

- ICMP Type 3 indicates Destination Unreachable
- ICMP Code 3 specifies Port Unreachable

This filter revealed **1083 ICMP responses**, indicating UDP closed-port scan results.

Q. Which UDP port is open in the 55–70 port range?

UDP traffic in the 55–70 port range was correlated with ICMP error responses.  
Port **68** generated UDP traffic **without corresponding ICMP Type 3 Code 3 responses**, indicating an open UDP service.


---

### ARP Poisoning / Spoofing (Man-In-The-Middle)

ARP (Address Resolution Protocol) maps IP addresses to MAC addresses on a local network. ARP poisoning (also known as ARP spoofing or MITM attack) exploits the lack of authentication in ARP by sending malicious ARP packets to manipulate IP-to-MAC mappings. The attacker positions themselves between the victim and the gateway to intercept traffic.

Key ARP characteristics:
- Works only on the local network
- Used for MAC-to-IP resolution
- Not secure and not routable
- No authentication mechanism
- Common packet types: request, response, gratuitous ARP

Basic ARP investigation filter:
`arp`

Useful ARP filters for detection:
- ARP requests: `arp.opcode == 1`
- ARP replies: `arp.opcode == 2`
- ARP scanning activity:
  `((arp) && (arp.opcode == 1)) && (arp.src.hw_mac == <target-mac>)`
- Possible ARP poisoning indicators:
  `arp.duplicate-address-detected`
  `arp.duplicate-address-frame`
- Suspicious destination MAC:
  `arp.dst.hw_mac == 00:00:00:00:00:00`

A suspicious ARP condition occurs when multiple MAC addresses claim ownership of the same IP address. Wireshark flags this as a duplicate address, but analysts must determine which packet is malicious by correlating timing, frequency, and network roles (gateway vs host).

Traffic analysis revealed a MAC address ending in **b4** repeatedly crafting ARP requests and responses:
- Legitimate ownership: MAC **b4** → IP **192.168.1.25**
- Spoofed claim: MAC **b4** also claimed **192.168.1.1** (likely gateway)
- Multiple ARP requests targeting a range of IPs indicated ARP flooding

This behavior confirms both **ARP spoofing** and **ARP flooding** attempts originating from the same host.

Further inspection of HTTP traffic initially appeared normal at the IP layer. After adding MAC address columns, all HTTP packets destined for the victim were observed flowing through the MAC ending in **b4**, confirming a successful MITM attack.

Final role identification:
- Attacker: MAC **00:0c:29:e2:18:b4** → IP **192.168.1.25**
- Gateway: MAC **50:78:b3:f3:cd:f4** → IP **192.168.1.1**
- Victim: MAC **00:0c:29:98:c7:a8** → IP **192.168.1.12**

This demonstrates how ARP poisoning enables traffic interception without altering IP-level communication, highlighting the importance of MAC-level inspection during investigations.


Exercise findings (ARP Exercise pcap):

Q. What is the number of ARP requests crafted by the attacker?

The following filter was used to isolate ARP requests sent by the attacker:
`arp.opcode == 1 && eth.src == 00:0c:29:e2:18:b4`

- `arp.opcode == 1` filters ARP request packets
- `eth.src == 00:0c:29:e2:18:b4` limits results to the attacker’s MAC address

This query revealed **284 ARP requests** crafted by the attacker.

Q. What is the number of HTTP packets received by the attacker?

HTTP traffic destined for the attacker was identified using:
`http && eth.dst == 00:0c:29:e2:18:b4`

- `http` filters cleartext HTTP traffic
- `eth.dst` confirms packets forwarded to the attacker’s MAC during MITM

This query returned **90 HTTP packets** received by the attacker.

Q. What is the number of sniffed username and password entries?

Credential-related HTTP payloads were filtered using:
`http contains uname`

- `contains` performs a case-sensitive string search
- `uname` matches username fields observed in HTTP form submissions

This revealed **6 username and password entries**.

Q. What is the password of "Client986"?

Client-specific HTTP traffic was identified using:
`http matches client986`

- `matches` performs a case-insensitive regex match
- Useful when exact casing is unknown

Inspection of the matching HTTP request revealed the password:
**clientnothere!**

Q. What is the comment provided by "Client354"?

Traffic related to the client was filtered using:
`http matches client354`

The HTTP payload inspection showed the following comment:
**Nice work!**

---

### Identifying Hosts: DHCP, NetBIOS and Kerberos

When investigating compromises or malware activity, identifying hosts and users is critical for defining the investigation scope and correlating malicious traffic. Beyond IP–MAC mappings, protocols such as DHCP, NetBIOS, and Kerberos provide valuable host and user attribution data.

Enterprise environments often use predictable naming conventions for hosts and users. While this simplifies asset management, it can also be abused by attackers, making protocol-level verification essential for analysts.

Protocols commonly used for host and user identification:
- DHCP (Dynamic Host Configuration Protocol)
- NetBIOS Name Service (NBNS)
- Kerberos

DHCP analysis focuses on extracting hostname, requested IP, and lease information from DHCP option fields. NetBIOS analysis helps identify workstation names through registration and query traffic. Kerberos analysis enables user and host identification in Windows domain environments by inspecting authentication metadata.

Exercise findings (dhcp-netbios.pcap & kerberos.pcap):

Q. What is the MAC address of the host "Galaxy A30"?

The following display filter was used:
`frame matches Galaxy`

This filter performs a case-insensitive search across packet frames, allowing quick identification of DHCP packets containing the hostname. Inspection of the matching DHCP Request revealed the MAC address:

**9a:81:41:cb:96:6c**

Q. How many NetBIOS registration requests does the "LIVALJM" workstation have?

The following filter was applied:
`(nbns.name matches LIVALJM) && (nbns.flags.opcode == 5)`

- `nbns.name matches LIVALJM` identifies NBNS packets related to the workstation
- `nbns.flags.opcode == 5` filters NetBIOS name registration requests

This resulted in **16 NetBIOS registration requests**.

Q. Which host requested the IP address "172.16.13.85"?

The DHCP request was identified using:
`dhcp && dhcp.option.requested_ip_address == 172.16.13.85`

After selecting a DHCP Request packet and inspecting the hostname option, the requesting host was identified as:

**Galaxy-A12**

Q. What is the IP address of the user "u5"? (defanged format)

Kerberos user activity was identified using:
`kerberos.CNameString contains "u5"`

- `CNameString` represents the client principal name (user or host)
- Values without `$` indicate user accounts

Packet inspection revealed the user "u5" associated with the following IP address:

**10[.]1[.]12[.]2**

Q. What is the hostname of the available host in the Kerberos packets?

Kerberos packets were filtered using:
`kerberos.CNameString`

Packets containing values ending with `$` were inspected, as these represent hostnames rather than user accounts. The available hostname identified was:

**xp1$**

