## Wireshark Traffic Analysis

### Nmap Scans

Nmap is a widely used network scanning tool for host discovery and service enumeration. SOC analysts must recognize traffic patterns generated by common Nmap scan types to identify reconnaissance activity.

Common scan types:
- TCP Connect Scan (`-sT`)
- TCP SYN Scan (`-sS`)
- UDP Scan (`-sU`)

Useful Wireshark filters for scan identification:
- `tcp`, `udp`
- SYN only: `tcp.flags.syn == 1`
- ACK only: `tcp.flags.ack == 1`
- SYN+ACK: `tcp.flags == 18`
- RST: `tcp.flags.reset == 1`
- FIN: `tcp.flags.fin == 1`

TCP Connect Scan characteristics:
- Completes the TCP three-way handshake
- Used by non-privileged users
- Window size typically greater than 1024
- Open port: SYN → SYN/ACK → ACK
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

TCP SYN Scan characteristics:
- Half-open scan (handshake not completed)
- Used by privileged users
- Smaller window size (≤ 1024)
- Open port: SYN → SYN/ACK → RST
- Closed port: SYN → RST/ACK
- Detection filter:
  `tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size <= 1024`

UDP Scan characteristics:
- No handshake mechanism
- Open ports usually do not respond
- Closed ports return ICMP Destination Unreachable (Type 3, Code 3)
- ICMP packets encapsulate the original UDP request
- Detection filter:
  `icmp.type == 3 and icmp.code == 3`

Exercise findings (Exercise.pcapng):

Q. How many TCP Connect scans are present in the capture?

To identify TCP Connect scans, the following filter was used:
`tcp.flags.syn == 1 and tcp.flags.ack == 0 and tcp.window_size > 1024`

- `tcp.flags.syn == 1` indicates a new connection attempt
- `tcp.flags.ack == 0` confirms this is the first packet of the handshake (not a response)
- `tcp.window_size > 1024` suggests a full TCP connection expecting data, typical of TCP Connect scans

This filter isolates outbound scan attempts from the scanner.  
The result showed **1000 TCP Connect scans**.

Q. Which scan type was used to scan TCP port 80?

TCP port 80 traffic was reviewed within the TCP Connect scan results identified above.  
All scan attempts on port 80 followed a full TCP handshake pattern, confirming a **TCP Connect scan**.

Q. How many UDP closed-port messages are present?

UDP closed ports were identified using ICMP error responses:
`icmp.type == 3 and icmp.code == 3`

- ICMP Type 3 indicates Destination Unreachable
- ICMP Code 3 specifies Port Unreachable

This filter revealed **1083 ICMP responses**, indicating UDP closed-port scan results.

Q. Which UDP port is open in the 55–70 port range?

UDP traffic in the 55–70 port range was correlated with ICMP error responses.  
Port **68** generated UDP traffic **without corresponding ICMP Type 3 Code 3 responses**, indicating an open UDP service.


---

### ARP Poisoning / Spoofing (Man-In-The-Middle)

ARP (Address Resolution Protocol) maps IP addresses to MAC addresses on a local network. ARP poisoning (also known as ARP spoofing or MITM attack) exploits the lack of authentication in ARP by sending malicious ARP packets to manipulate IP-to-MAC mappings. The attacker positions themselves between the victim and the gateway to intercept traffic.

Key ARP characteristics:
- Works only on the local network
- Used for MAC-to-IP resolution
- Not secure and not routable
- No authentication mechanism
- Common packet types: request, response, gratuitous ARP

Basic ARP investigation filter:
`arp`

Useful ARP filters for detection:
- ARP requests: `arp.opcode == 1`
- ARP replies: `arp.opcode == 2`
- ARP scanning activity:
  `((arp) && (arp.opcode == 1)) && (arp.src.hw_mac == <target-mac>)`
- Possible ARP poisoning indicators:
  `arp.duplicate-address-detected`
  `arp.duplicate-address-frame`
- Suspicious destination MAC:
  `arp.dst.hw_mac == 00:00:00:00:00:00`

A suspicious ARP condition occurs when multiple MAC addresses claim ownership of the same IP address. Wireshark flags this as a duplicate address, but analysts must determine which packet is malicious by correlating timing, frequency, and network roles (gateway vs host).

Traffic analysis revealed a MAC address ending in **b4** repeatedly crafting ARP requests and responses:
- Legitimate ownership: MAC **b4** → IP **192.168.1.25**
- Spoofed claim: MAC **b4** also claimed **192.168.1.1** (likely gateway)
- Multiple ARP requests targeting a range of IPs indicated ARP flooding

This behavior confirms both **ARP spoofing** and **ARP flooding** attempts originating from the same host.

Further inspection of HTTP traffic initially appeared normal at the IP layer. After adding MAC address columns, all HTTP packets destined for the victim were observed flowing through the MAC ending in **b4**, confirming a successful MITM attack.

Final role identification:
- Attacker: MAC **00:0c:29:e2:18:b4** → IP **192.168.1.25**
- Gateway: MAC **50:78:b3:f3:cd:f4** → IP **192.168.1.1**
- Victim: MAC **00:0c:29:98:c7:a8** → IP **192.168.1.12**

This demonstrates how ARP poisoning enables traffic interception without altering IP-level communication, highlighting the importance of MAC-level inspection during investigations.


Exercise findings (ARP Exercise pcap):

Q. What is the number of ARP requests crafted by the attacker?

The following filter was used to isolate ARP requests sent by the attacker:
`arp.opcode == 1 && eth.src == 00:0c:29:e2:18:b4`

- `arp.opcode == 1` filters ARP request packets
- `eth.src == 00:0c:29:e2:18:b4` limits results to the attacker’s MAC address

This query revealed **284 ARP requests** crafted by the attacker.

Q. What is the number of HTTP packets received by the attacker?

HTTP traffic destined for the attacker was identified using:
`http && eth.dst == 00:0c:29:e2:18:b4`

- `http` filters cleartext HTTP traffic
- `eth.dst` confirms packets forwarded to the attacker’s MAC during MITM

This query returned **90 HTTP packets** received by the attacker.

Q. What is the number of sniffed username and password entries?

Credential-related HTTP payloads were filtered using:
`http contains uname`

- `contains` performs a case-sensitive string search
- `uname` matches username fields observed in HTTP form submissions

This revealed **6 username and password entries**.

Q. What is the password of "Client986"?

Client-specific HTTP traffic was identified using:
`http matches client986`

- `matches` performs a case-insensitive regex match
- Useful when exact casing is unknown

Inspection of the matching HTTP request revealed the password:
**clientnothere!**

Q. What is the comment provided by "Client354"?

Traffic related to the client was filtered using:
`http matches client354`

The HTTP payload inspection showed the following comment:
**Nice work!**

---

### Identifying Hosts: DHCP, NetBIOS and Kerberos

When investigating compromises or malware activity, identifying hosts and users is critical for defining the investigation scope and correlating malicious traffic. Beyond IP–MAC mappings, protocols such as DHCP, NetBIOS, and Kerberos provide valuable host and user attribution data.

Enterprise environments often use predictable naming conventions for hosts and users. While this simplifies asset management, it can also be abused by attackers, making protocol-level verification essential for analysts.

Protocols commonly used for host and user identification:
- DHCP (Dynamic Host Configuration Protocol)
- NetBIOS Name Service (NBNS)
- Kerberos

DHCP analysis focuses on extracting hostname, requested IP, and lease information from DHCP option fields. NetBIOS analysis helps identify workstation names through registration and query traffic. Kerberos analysis enables user and host identification in Windows domain environments by inspecting authentication metadata.

Exercise findings (dhcp-netbios.pcap & kerberos.pcap):

Q. What is the MAC address of the host "Galaxy A30"?

The following display filter was used:
`frame matches Galaxy`

This filter performs a case-insensitive search across packet frames, allowing quick identification of DHCP packets containing the hostname. Inspection of the matching DHCP Request revealed the MAC address:

**9a:81:41:cb:96:6c**

Q. How many NetBIOS registration requests does the "LIVALJM" workstation have?

The following filter was applied:
`(nbns.name matches LIVALJM) && (nbns.flags.opcode == 5)`

- `nbns.name matches LIVALJM` identifies NBNS packets related to the workstation
- `nbns.flags.opcode == 5` filters NetBIOS name registration requests

This resulted in **16 NetBIOS registration requests**.

Q. Which host requested the IP address "172.16.13.85"?

The DHCP request was identified using:
`dhcp && dhcp.option.requested_ip_address == 172.16.13.85`

After selecting a DHCP Request packet and inspecting the hostname option, the requesting host was identified as:

**Galaxy-A12**

Q. What is the IP address of the user "u5"? (defanged format)

Kerberos user activity was identified using:
`kerberos.CNameString contains "u5"`

- `CNameString` represents the client principal name (user or host)
- Values without `$` indicate user accounts

Packet inspection revealed the user "u5" associated with the following IP address:

**10[.]1[.]12[.]2**

Q. What is the hostname of the available host in the Kerberos packets?

Kerberos packets were filtered using:
`kerberos.CNameString`

Packets containing values ending with `$` were inspected, as these represent hostnames rather than user accounts. The available hostname identified was:

**xp1$**

---

### Tunnelling Traffic: ICMP and DNS

Traffic tunnelling hides data inside legitimate protocols to move information across network boundaries. While commonly used by enterprises for secure communication, attackers abuse trusted protocols like ICMP and DNS for data exfiltration and command-and-control (C2) communication to bypass security controls.

Because these protocols are routinely allowed through network perimeters, detecting tunnelling requires identifying anomalies rather than relying on simple allow/deny logic.

ICMP tunnelling abuses the ICMP payload field to encapsulate other protocols such as SSH, TCP, or HTTP. DNS tunnelling abuses long or abnormal DNS queries, often encoding data inside subdomain labels.

ICMP tunnelling indicators include:
- High volume of ICMP traffic
- Abnormal or consistent packet sizes
- Encapsulated protocol data inside ICMP payloads

DNS tunnelling indicators include:
- Excessively long DNS query names
- Encoded or random-looking subdomains
- Repeated queries to a single domain
- Known tunnelling tools (e.g., dnscat, dns2tcp)

Exercise findings (icmp-tunnel.pcap & dns.pcap):

Q. Which protocol is used in the ICMP tunnelling activity?

ICMP packets with unusually large payloads were isolated using:
`data.len > 64 and icmp`

- Normal ICMP echo requests are typically 64 bytes
- Larger payloads indicate possible data encapsulation

Inspection of the ICMP payload revealed encapsulated **SSH** traffic, confirming ICMP-based tunnelling.

Q. What is the suspicious main domain receiving anomalous DNS queries? (defanged format)

DNS tunnelling activity was isolated using:
`dns.qry.name.len > 15 and !mdns`

- Long query names indicate encoded subdomain data
- `!mdns` removes local multicast DNS noise

Analysis showed repeated anomalous DNS queries targeting the following domain:

**dataexfil[.]com**

---

### Cleartext Protocol Analysis: FTP

Cleartext protocol analysis becomes challenging at scale. While credentials and commands are readable, a SOC analyst must extract statistics, identify abuse patterns, and summarize attacker behavior rather than simply following streams.

FTP prioritizes simplicity over security and transmits credentials and commands in cleartext, making it highly vulnerable to interception and abuse. Common risks include credential theft, brute-force attacks, malware uploads, and data exfiltration.

FTP investigation relies on correlating response codes, commands, and file-transfer activity to identify attacker intent.

Key FTP indicators:
- Authentication attempts (success and failure)
- File access and transfer activity
- Permission modification commands
- Repeated failed logins indicating brute-force behavior

Exercise findings (ftp.pcap):

Q. How many incorrect login attempts are there?

Incorrect login attempts were identified using:
`ftp && ftp.response.arg == "Login incorrect."`

- `ftp` limits traffic to FTP protocol
- `ftp.response.arg == "Login incorrect."` directly matches failed authentication responses returned by the server

This filter revealed **737 incorrect login attempts**, indicating brute-force activity.

Q. What is the size of the file accessed by the "ftp" account?

FTP activity related to the "ftp" account was identified using:
`ftp contains "ftp"`

After locating the first `USER ftp` command, the packet was right-clicked and filtered using:
**Conversation Filter → TCP**

This isolated the full FTP session for that user. Scrolling through the conversation revealed a file transfer where the server response contained:

`Response arg: 39424`

This indicates the accessed file size was **39424 bytes**.

Q. What is the filename uploaded by the adversary?

The uploaded filename was identified during the same TCP conversation filtered in the previous step.

Inspection of the FTP commands within the session revealed the uploaded file:

**resume.doc**

Q. What command was used to change the execution permissions of the uploaded file?

Post-upload FTP commands were reviewed by continuing to scroll through the same TCP conversation.

The adversary attempted to modify file permissions using the following command:

**CHMOD 777 resume.doc**



